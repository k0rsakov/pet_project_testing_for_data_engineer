# Тестирование в Дата-инженерии | Testing in Data Engineering

https://www.notion.so/korsak0v/Data-Engineer-185c62fdf79345eb9da9928356884ea0

## О видео

## О проекте

### О тестировании

Тестирование – это инструмент контроля качества кода и бизнес-логики. Для дата-инженера тесты позволяют:

- **Своевременно находить ошибки** на этапе разработки, а не на проде.
- **Гарантировать корректность обработки данных** – ошибки в пайплайнах могут влиять на отчёты, решения и деньги.
- **Экономить время и ресурсы** – автоматические тесты быстро проверяют весь проект, сокращая ручную работу и расходы на
  исправление багов.
- **Повышать доверие к продукту** – со стороны команды аналитиков, заказчиков и бизнеса.
- **Упрощать развитие и поддержку кода** – тесты защищают от случайных поломок при изменениях и позволяют эффективно
  работать в команде.

Хорошие тесты – уверенность в качестве данных и стабильной работе всей дата-инфраструктуры.

#### Пирамида тестирования

В промышленной разработке тесты принято делить на несколько уровней – по охвату и стоимости их запуска. Это называют "
*пирамидой тестирования*":

1. **Юнит-тесты** – проверяют работу отдельных функций и классов.
    - Быстрые, простые, пишутся много.
    - Идеальны для проверки преобразования данных, небольшой логики.
2. **Интеграционные тесты** – проверяют, как части системы работают вместе.
    - Например: функция + база данных, API + очереди, несколько сервисов.
    - Медленнее, сложнее настройки.
3. **End-to-end (E2E, сквозные) тесты** – покрывают весь процесс "от начала до конца" (например, полный запуск DAG-а и
   проверки результата).
    - Дорого запускать, покрывают меньше сценариев.
    - Проверяют реальный рабочий процесс целиком.

**Зачем нужна пирамида?**

- Юнит-тестов пишут больше всего – они быстрые и дешёвые.
- По мере движения вверх по пирамиде тесты становятся “дороже”, но дают больше уверенности в работе всей системы.

**Итог:**  
Хорошая культура тестирования опирается на пирамиду: много юнит-тестов, меньше интеграционных, и только небольшое число
e2e.

![](readme_files/testing_pyramid_svg.svg)

### Виртуальное окружение

Настройка виртуального окружения:

```bash
python3.12 -m venv venv && \
source venv/bin/activate && \
pip install --upgrade pip && \
pip install poetry && \
poetry lock && \
poetry install
```

### Настройка Airflow через Docker

Мы используем Airflow, который собирается при помощи [Dockerfile](Dockerfile)
и [docker-compose.yaml](docker-compose.yaml).

Для запуска контейнера с Airflow, выполните команду:

```bash
docker-compose up -d
```

Веб-сервер Airflow запустится на хосте http://localhost:8080/, если не будет работать данный хост, то необходимо перейти
по хосту http://0.0.0.0:8080/.

#### Добавление пакетов в текущую сборку

Для того чтобы добавить какой-то пакет в текущую сборку, необходимо выполнить следующие шаги:

* Добавить новую строку в [Dockerfile](Dockerfile)
* Выполнить команду:

```bash
docker-compose build
```

* Выполнить команду:

```bash
docker-compose up -d
```

### Тестирование на практике

Запуск через терминал простых тестов:

```bash
python -m pytest tests/test_*
```

Запуск через терминал конкретного класса с тестами:

```bash
python -m pytest tests/dags/extensions_for_orchestration/test_extensions_dict.py::TestDictKeysInStr
```

Запуск тестов с конкретным тегом:

```bash
python -m pytest -m unit
```

Как заменить мета-стор для Airflow в виртуальном окружении:

Airflow работает в `venv` и он использует тот коннект, что задаётся по-умолчанию. Для просмотра информации о Airflow
необходимо выполнить команду – `airflow info`. А для того, чтобы найти информацию о мета-сторе –
`airflow config get-value database sql_alchemy_conn`. Теперь мы видим какая используется БД для мета-данных.

Теперь нужно найти "*дом*" для Airflow, это есть в `airflow info` – `airflow_home`. Идём туда и открываем файл
`airflow.cfg`. Ищем ключ `sql_alchemy_conn`. Изменяем на (пример) –
`sql_alchemy_conn = postgresql+psycopg2://airflow:airflow@localhost:5432/airflow`

Запуск всех тестов:
```bash
python -m pytest tests/
```

Запуск покрытия:
```bash
python -m pytest --cov=. tests/ --cov-report=html
```
Рекомендации:
1) Основной совет – когда пишете функцию, держите мысль о том как вы будете её тестировать. Если вы уже "*задумались*", что нужно много тестов, то начинайте декомпозировать задачу.
    1) \*Вредный совет. Но если вы пишете какой-то фреймворк или код, который будет переиспользоваться в команде, то
       без тестов никуда.
2) Явное лучше неявного, поэтому давайте такой нейминг функциям и тестам, чтобы было всё однозначно. К примеру, наша
   первая функция `return_value` ничего не говорит о функции. Также это касается нейминга тестов, особенно это полезно,
   если тест упадёт, то будет +- понятно что это.
3) Не ленитесь писать документацию для тестов. Особенно тестов, которые касаются бизнес-логики и краевых случаев.
4) Используйте юнит-тесты как дебаг методов и понимания как она работает. Конкретный тест или тесты по функции проще
   запустить, чем "*отделить*" функцию и выполнить её
5) Интегрируйте тесты в CICD. Так как вы можете "*тонко*" настраивать тесты, то вы "*тонко*" можете настроить CICD.
   К примеру, e2e-тесты запускать только в том случае, если при MR указан какой-то лэйбл. Или сначала запускать
   юнит-тесты, а потом интеграционные. Потому что интеграционные тесты используют функции, которые должны быть
   покрыты в юнит-тестах.
6) Настраивайте правильно модуль `coverage`, потому что 100% != 100%
